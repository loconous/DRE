/**
 *  blobs.js
 *  Functions related to retrieving blob data
 */
//Testing sha a8fe822f075fa3d159a203adfa40c3f59d6dd999 (License file)
const execLookup = require('../lookup/lookup'); 
const EMPTY_FILE_HASH = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
/**
 * Based on Dr. Reid's b2ob, which uses WoC's lookup/getValues to retrieve old blobs 
 * @params sha1 - Sha1 hash of a blob
 * @returns An array of sha1 hashes of old blobs
 */
async function b2ob(blob) {
    //Call lookup/getValues with b2ob to get old blobs from a list of blobs. 
    //Blobs are separated by a newline
    const ret = await execLookup(blob.join('\r\n'), "getValues", "-f b2ob");
    let blobs = ret.stdout.split('\n');
    //Creates an array of arrays from blobs. Only includes arrays that are non-empty. Hashes are separated by a semicolon, so this is filtered out
    blobs = blobs.map(b => b.split(';').filter(b => b != '')).filter(arr => arr.length);
    return blobs;
}
/**
 *  Get all old blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function ob2b(blob) {
    const ret = await execLookup(blob.join('\r\n'), "getValues", "-f ob2b");
    let blobs = ret.stdout.split('\n');
    blobs = blobs.map(b => b.split(';').filter(b => b != '')).filter(arr => arr.length);
    return blobs;
}
/**
 * Based on Dr. Reid's ob2b_r, which recursively gets blobs in WoC using ob2b
 * mapping 
 * @params sha1 - Sha1 hash of a blob
 * @params list - List of blobs already found
 */

async function ob2b_r(blob, blobList) {
   //Get old blobs from current blob. 
   let blobs = await ob2b(blob);
   blob.forEach(b => blobList.push(b));
   let uniqueBlobs = [];
    //Check to see if there are any unique blobs in the current collection of blobs
    for(let i = 0; i < blobs.length; i++) {
        for(let j = 0; j < blobs[i].length; j++) {
            if(!blobList.includes(blobs[i][j])) {
                uniqueBlobs.push(blobs[i][j]);
            }
        }
    }
    //If there are any new unique blobs, call ob2b_r on them
    if(uniqueBlobs.length != 0) {
        return ob2b_r(uniqueBlobs, blobList);
    } 
    return blobList;

}
/**
 * Based on Dr. Reid's b2ob_r, which recursively gets blobs in WoC using b2ob   mapping 
 * @params sha1 - Sha1 hash of a blob
 * @params list - List of blobs already found
 */
async function b2ob_r(blob, blobList) {
   //Get old blobs from current blob. 
   let blobs = await b2ob(blob);
   blob.forEach(b => blobList.push(b));
   let uniqueBlobs = [];
    //Check to see if there are any unique blobs in the current collection of blobs
    for(let i = 0; i < blobs.length; i++) {
        for(let j = 0; j < blobs[i].length; j++) {
            if(!blobList.includes(blobs[i][j])) {
                uniqueBlobs.push(blobs[i][j]);
            }
        }
    }
    //If there are any new blobs, call b2ob_r on them
    if(uniqueBlobs.length != 0) {
        return b2ob_r(uniqueBlobs, blobList);
    } 
    return blobList;
}

/**
 * Get the contents of a blob from lookup/showCnt
 * @param blob - Blob hash 
 */
async function getBlobContents(blob) {
    const ret = await execLookup(blob, "showCnt", "blob");
    //? Is this needed?
}
/**
 * Get commits of blob
 * @param blob - Blob hash
 */
async function getBlobCommits(blob) {
    //TODO: Error handling (make sure stdout isn't null)
    const ret = await execLookup(blob, "getValues", "b2c");
    let commits = ret.stdout.split(';');
    commits = commits.filter(c => c != '');
    return commits;
}
/**
 * Get info about each commit,
 * @param {*} commit Commit hash
 */
async function getCommitInfo(commit) {
    //TODO: Error handling (make sure stdout isn't null)
    let commitInfo = {};
    const ret = await execLookup(commit, "showCnt", "commit");
    let [commitID, treeID, parentID, author, committer, authorTime, committerTime] = ret.stdout.split(';');
    //FIXME: This could probably be done in a Promise.all to save a bit of time
    let projects = await getProjectInfo(commit);
    let deforkedProjects = await getDeforkedProjectInfo(commit);
    commitInfo = {
        commit: commitID,
        tree: treeID,
        parent: parentID,
        author: typeof author != 'undefined' ? author : "",
        committer: committer,
        authorTime: authorTime,
        committerTime: committerTime,
        projects: projects,
        deforkedProjects: deforkedProjects,
        numProjects: projects.length,
        numDeforkedProjects: deforkedProjects.length,
    }

    return commitInfo;
}
/**
 * Get the name of each project a commit is connected to 
 * @param commit Commit hash
 */
async function getProjectInfo(commit) {
    const ret = await execLookup(commit, "getValues", "c2p");
    let projects = ret.stdout.split(';');
    projects = projects.filter(p => p != '').filter(p => typeof(p) != 'undefined');
    console.log("PROJECTS: ", projects);
    return projects;
}
async function getDeforkedProjectInfo(commit) {
    const ret = await execLookup(commit, "getValues", "c2P");
    let projects = ret.stdout.split(';');
    projects = projects.filter(p => p != '').filter(p => typeof(p != 'undefined'));
    return projects;
}

async function handleBlob(blob) {
    //Get all commits for a blob.
    let blobInfo = {};
    let rawCommits = await getBlobCommits(blob);
    //Get info about each commit.
    let commitsWithInfo = await Promise.all(rawCommits.map(commit => getCommitInfo(commit)));
    //Get unique authors from all commits for this blob
    let authors = [...new Set(commitsWithInfo.map(commit => commit.author))].filter(author => author != '');
    //Sort by latest commit
    commitsWithInfo = commitsWithInfo.sort((a,b) => {
        a.authorTime > b.authorTime;
    })
    blobInfo = {
        hash: blob,
        commits: commitsWithInfo,
        numCommits: commitsWithInfo.length,
        totalProjects: commitsWithInfo.map(commit => commit.numProjects).reduce((a,b) => a+b, 0),
        authors: authors,
        numAuthors: authors.length,
    }
    return blobInfo;
}



/**
 *  Get all old blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function getOldBlobs(sha1) {
    let blobList = [EMPTY_FILE_HASH];
    const blob = [sha1];
    const res = await b2ob_r(blob, blobList);
    return res;
}
/**
 * Get all new blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function getNewBlobs(sha1) {
    let blobList = [EMPTY_FILE_HASH];
    const blob = [sha1];
    const res = await ob2b_r(blob, blobList);
    return res;
}

module.exports = {
    getOldBlobs,
    getNewBlobs,
    handleBlob
}