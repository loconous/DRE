/**
 *  blobs.js
 *  Functions related to retrieving blob data
 */
//Testing sha a8fe822f075fa3d159a203adfa40c3f59d6dd999
const execLookup = require('../lookup/lookup'); 
const EMPTY_FILE_HASH = "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391";
/**
 * Based on Dr. Reid's b2ob, which uses WoC's lookup/getValues to retrieve old blobs 
 * @params sha1 - Sha1 hash of a blob
 * @returns An array of sha1 hashes of old blobs
 */
async function b2ob(blob) {
    //Call lookup/getValues with b2ob to get old blobs from a list of blobs. 
    //Blobs are separated by a newline
    const ret = await execLookup(blob.join('\r\n'), "getValues", "-f b2ob");
    let blobs = ret.stdout.split('\n');
    blobs = blobs.map(b => b.split(';').filter(b => b != '')).filter(arr => arr.length);
    return blobs;
}
/**
 *  Get all old blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function ob2b(blob) {
    const ret = await execLookup(blob.join('\r\n'), "getValues", "-f ob2b");
    let blobs = ret.stdout.split('\n');
    blobs = blobs.map(b => b.split(';').filter(b => b != '')).filter(arr => arr.length);
    return blobs;
}
/**
 * Based on Dr. Reid's ob2b_r, which recursively gets blobs in WoC using ob2b
 * mapping 
 * @params sha1 - Sha1 hash of a blob
 * @params list - List of blobs already found
 */

async function ob2b_r(blob, blobList) {
   //Get old blobs from current blob. 
   let blobs = await ob2b(blob);
   blob.forEach(b => blobList.push(b));
   let uniqueBlobs = [];
    //Check to see if there are any unique blobs in the current collection of blobs
    for(let i = 0; i < blobs.length; i++) {
        for(let j = 0; j < blobs[i].length; j++) {
            if(!blobList.includes(blobs[i][j])) {
                uniqueBlobs.push(blobs[i][j]);
            }
        }
    }
    //If there are any new unique blobs, call ob2b_r on them
    if(uniqueBlobs.length != 0) {
        return ob2b_r(uniqueBlobs, blobList);
    } 
    return blobList;

}
/**
 * Based on Dr. Reid's b2ob_r, which recursively gets blobs in WoC using b2ob   mapping 
 * @params sha1 - Sha1 hash of a blob
 * @params list - List of blobs already found
 */
async function b2ob_r(blob, blobList) {
   //Get old blobs from current blob. 
   let blobs = await b2ob(blob);
   blob.forEach(b => blobList.push(b));
   let uniqueBlobs = [];
    //Check to see if there are any unique blobs in the current collection of blobs
    for(let i = 0; i < blobs.length; i++) {
        for(let j = 0; j < blobs[i].length; j++) {
            if(!blobList.includes(blobs[i][j])) {
                uniqueBlobs.push(blobs[i][j]);
            }
        }
    }
    //If there are any new blobs, call b2ob_r on them
    if(uniqueBlobs.length != 0) {
        return b2ob_r(uniqueBlobs, blobList);
    } 
    return blobList;
}

/**
 *  Get all old blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function getOldBlobs(sha1) {
    let blobList = [EMPTY_FILE_HASH];
    const blob = [sha1];
    const res = await b2ob_r(blob, blobList);
    return res;
}
/**
 * Get all new blobs in WoC from an initial blob hash
 * @params sha1 - Sha1 hash of a blob
 */
async function getNewBlobs(sha1) {
    let blobList = [EMPTY_FILE_HASH];
    const blob = [sha1];
    const res = await ob2b_r(blob, blobList);
    return res;
}

module.exports = {
    getOldBlobs,
    getNewBlobs
}